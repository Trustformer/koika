Require Import Koika.BitsToLists Koika.Environments
  Koika.SimpleFormInterpretation Koika.SimpleVal Koika.Wt.

(* Ltac prepare_smpl := *)
(*   let wfsf := fresh "wfsf" in *)
(*   let lassoc := fresh "lassoc" in *)
(*   lazymatch goal with *)
(*   | RV: getenv ?REnv ?ctx ?rg = ?vl, *)
(*     WTRENV : Wt.wt_renv ?R ?REnv ?ctx, *)
(*     WFSF' : wf_sf ?R ?ext_Sigma ?sf' *)
(*     |- *)
(*      getenv ?REnv (interp_cycle ?ctx ?ext_sigma (replace_reg ?sf' ?rg ?vl)) ?rg *)
(*      = _ *)
(*     => *)
(*     set ( *)
(*       wfsf := *)
(*         wf_sf_replace_reg *)
(*           (ext_fn_t := ?ext_fn_t) (REnv := ?REnv) ?R ?ext_Sigma *)
(*             ?ctx WTRENV rg vl sf' RV WFSF' *)
(*     ); unfold WFSF' in wfsf; clear WFSF' *)
(*   | WTRENV : Wt.wt_renv ?R ?REnv ?ctx, *)
(*     WFSF' : wf_sf ?R ?ext_Sigma ?sf', *)
(*     WT_SIGMA : *)
(*       forall (ufn : ?ext_fn_t) (vc : val), *)
(*       wt_val (arg1Sig (?ext_Sigma ufn)) vc *)
(*       -> wt_val (retSig (?ext_Sigma ufn)) (?ext_sigma ufn vc) *)
(*     |- getenv ?REnv *)
(*          (interp_cycle ?ctx ?ext_sigma (simplify_sf ?ctx ?ext_sigma ?sf')) ?rg *)
(*        = _ *)
(*     => *)
(*     set ( *)
(*       wfsf := *)
(*         wf_sf_simplify_sf *)
(*           (wt_sigma := WT_SIGMA) (ext_fn_t := ?ext_fn_t) *)
(*           (REnv := ?REnv) ?R ?ext_Sigma ?ctx ?ext_sigma WTRENV sf' WFSF' *)
(*     ); unfold WFSF' in wfsf; clear WFSF' *)
(*   | WTRENV : Wt.wt_renv ?R ?REnv ?ctx, *)
(*     WFSF' : wf_sf ?R ?ext_Sigma ?sf' *)
(*     |- getenv ?REnv *)
(*          (interp_cycle ?ctx ?ext_sigma *)
(*            (prune_irrelevant_aux (collapse_sf ?sf') ?rg ?l) *)
(*          ) ?rg = _ *)
(*     => *)
(*     assert (list_assoc (final_values (collapse_sf sf')) rg = Some l) *)
(*       as lassoc by (vm_compute list_assoc; reflexivity); *)
(*     set ( *)
(*       wfsf := *)
(*         wf_sf_prune_irrelevant_aux (ext_fn_t := ?ext_fn_t) ?R *)
(*           ?ext_Sigma (collapse_sf sf') rg l lassoc *)
(*           (wf_collapse_sf ?R ?ext_Sigma sf' WFSF') *)
(*     ); *)
(*     unfold WFSF' in wfsf; clear WFSF' *)
(*   | WTRENV : Wt.wt_renv ?R ?REnv ?ctx, *)
(*     WFSF' : wf_sf ?R ?ext_Sigma ?sf' *)
(*     |- getenv ?REnv *)
(*          (interp_cycle ?ctx ?ext_sigma (prune_irrelevant_aux ?sf' ?rg ?l)) ?rg *)
(*        = _ *)
(*     => *)
(*     (1* TODO also keep a single live version of lassoc *1) *)
(*     assert (list_assoc (final_values sf') rg = Some l) *)
(*       as lassoc by (vm_compute list_assoc; reflexivity); *)
(*     set ( *)
(*       wfsf := *)
(*         wf_sf_prune_irrelevant_aux (ext_fn_t := ?ext_fn_t) ?R *)
(*         ?ext_Sigma sf' rg l lassoc WFSF' *)
(*     ); unfold WFSF' in wfsf; clear WFSF' *)
(*     (1* ; clear lassoc *1) *)
(*   | |- _ => idtac *)
(*   end. *)
